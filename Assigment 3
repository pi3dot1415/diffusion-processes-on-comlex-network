import networkx as nx
import random
import numpy as np

class GraphGenerator ():

    def __init__(self, directed:bool=False) -> None:
        """
        """
        self.directed = directed
        if directed:
            self.graph = nx.DiGraph()
        else:
            self.graph = nx.Graph()

    def random_Graph (self, N:int, e:int=-1) -> None:
        """
        Function generate random graph by information about number of nodes 
        and edges (optional). There is possibility to generate either directed 
        or undirected graph but they cannot be connected with themselves.
        
        Arguments:
            N (int): Number of nodes which will be added to the graph
            e (int): Deafult -1. Number of edges. If value exceeds possible number of nodes function generates fully-connected graph.
                        If number is negative function generate random number of connections.
            directed (bool): Deafult "False", allows user to create directed graph.
        
        Returns:
            None
        """

        #Checking if user set number of new edges to randomor if number is greater than possible number of edges.
        #Number of possible edges is greater in directed case so it has to be take into account.
        if e<0 & self.directed:
            e=random.randint(0, N*(N-1))
        elif e<0:
            e=random.randint(0, (N-1)*N/2)
        elif e>N*(N-1) & self.directed:
            e = N*(N-1)
        elif e>N*(N-1)/2 & (not self.directed):
            e = N*(N-1)/2
        
        #Adding nodes to graph
        self.graph.add_nodes_from(np.arange(N))

        #Creating list with all possible edges
        self.allEdges = []
        for i in range(N):
            for j in range(N):
                if i>=j & (not self.directed):
                    self.allEdges.append([i,j])
                elif i!=j:
                    self.allEdges.append([i,j])
        
        #Shuffling list of possible edges because they should be randomly chosen
        random.shuffle(self.allEdges)
        
        #Adding to graph first e edges from list
        self.graph.add_edges_from(self.allEdges[:e])

    def wattStrogatzGraph (self, N:int) -> None:
        """
        Function creates Watt-Strogatz graph.

        Arguments:

        Return:
            None
        """
        pass

    def barabasiAlbertGraph (self, N:int, M:list) -> None:
        """
        Function creates Barabasi-Albert graph (new nodes are connected with "old" ones which has choosen proportionally to number of their neighbours).

        Arguments:
            N (int): Number of new nodes.
            M (list): Not empty list of edges from which graph will grow.

        Return:
            None
        """

        #Adding given edges to the graph.
        self.graph.add_edges_from(M)

        #Creating list for which store names of vertices proportionally times to their number of neighbors. 
        node_weight = []
        for verts in self.graph.nodes:
            for ns in nx.neighbors(self.graph, verts):
                node_weight.append(verts)
        
        #Creating list of names of futer nodes (it has to be longer than N, because some names can be already used)
        m=len(self.graph.nodes)
        t=np.arrange(N+m)
        
        #Removing names which were used in the graph
        for vertices in self.graph.nodes:
            t.remove(vertices)

        #Taking needed number of names
        t=t[:N]
        
        #Adding edges to graph (every new node is connected with randomly chosen 
        #(with probability proportional to number of neighbors) node from list M)
        for i in range(N):
            self.graph.add_edge((random.choice(node_weight), t[i]))

G=GraphGenerator(directed=True)

G.random_Graph(N=2, edges=15)
