class Graph():

    def __init__(self) -> object:
        """
        Function creates a new, empty undirected graph.
        
        Arguments:
            None
        Return:
            graph (Graph): Empty graph object
        """
        
        #Creating variables which defining graph
        self.allEdges=[]
        self.allVertices=[]

    def addVertex(self, vert):
        """
        Add single node to the graph.
        
        Arguments:
            vert (any): name of vertex
        Return:
            None
        """
        
        #Adding new vertex
        
        #Checking if vertex is already in the graph
        if vert not in self.allVertices:
            self.allVertices.append(vert) #if not, adding to the graph

    def addVerticesFromList(self, vertList):
        """
        Add multiple vertices to the graph.
        
        Arguments:
            vertList (list): list of names of vertices
        Return:
            None
        """

        #Adding new vertices
        
        #Checking if vertices are in the the graph
        for verts in vertList:
            if verts not in self.allVertices:
                self.allVertices.append(verts) #if not, adding to the graph

    def edgesChecker(self, fromVert, toVert) -> bool:
        """
        Checking if particular vertices have edge between them.

        Arguments:
            fromVert (any): first vertex
            toVert (any): second vertex
        Return:
            bl (bool): True if there is connection and false otherwise
        """
        tempVar=[]
        for edges in self.allEdges: tempVar+=[edges[:2]]
        if (fromVert, toVert) or (toVert, fromVert) in tempVar:
            return(False)
        else:
            return(True)
    
    def addEdge(self, fromVert, toVert, weight=None):
        """
        Adding one edge between 2 nodes (which don't have to already exist).
        If connection between those nodes exist then command is ignored.
        the order of fromVert and toVert doesn't matter.

        Arguments:
            fromVert (any): name of first vert 
            toVert (any): name of second vert
            weight (any [optional]): adds weight to 
        Return:
            None
        """

        try:
            if fromVert not in self.allVertices:
                self.allVertices.append(fromVert)
            if toVert not in self.allVertices:
                self.allVertices.append(toVert)
            bl = self.edgesChecker(fromVert, toVert)
            if weight and not bl:
                self.allEdges.append((fromVert, toVert, weight))
            elif not bl:
                self.allEdges.append((fromVert, toVert))
        except:
            print("Incorrect values")

    def addEdgesFromList(self, edgeList):
        """
        Adding multiple edges between 2 nodes each (which don't have to already exist).
        If connection between some of these nodes exist then connection is not added for them.
        the order of nodes in tuple or order of tuples doesn't matter.
        
        Arguments:
            edgeList (list of tuples): list of tuples with edges
        Return:
            None
        """
        try:
            for edges in edgeList:
                if edges[0] not in self.allVertices:
                    self.allVertices.append(edges[0])
                if edges[1] not in self.allVertices:
                    self.allVertices.append(edges[1])
                bl = self.edgesChecker(edges[0], edges[1])
                if not bl:
                    self.allEdges.append(edges)
        except:
            print("Incorrect value")

    def getVertices(self) -> list:
        """
        Function returns list of all vertices in graph.
        
        Arguments:
            None
        Return:
            (list): list of all vertices
        """
        return(self.allVertices)

    def getEdges(self) -> list:
        """
        Function returns list of all edges in graph. 
        
        Arguments:
            None
        Return:
            (list of tuples): list of all edges 
        """
        return(self.allEdges)

    def getNeighbours(self, vertKey) -> list:
        """
        Returns list of vertices which are neighbours of particular node (vertKey).
        
        Arguments:
            vertKey (any): name of node
        Return:
            neighbours (list): list of neighbours
        """
        
        neighbour_list = []
        for edges in self.allEdges:
            if vertKey == edges[0]:
                neighbour_list.append(edges[1])
            elif vertKey == edges[1]:
                neighbour_list.append(edges[0])
        
        return (neighbour_list)

    def __contains__ (graph, vertKey) -> bool:
        """
        Function return information if vertice is in the graph
        
        Arguments:
            vertKey (any): checked node name
            graph (Graph)): checked graph 
        Return:
            bl (bool): information if node is in graph 
        """

        return(vertKey in graph.allVertices) 

    def saveGraph(self, graph):
        """
        Save graph in text file using dot representation.
        
        Arguments:
            graph
        Return:
            
        """
        #how to do this?
        pass

    def checkPath(self, vertex):
        """
        Function check with which new vertices exist edge to particular node.

        Arguments:
            vertex (any): started node
        Return:
            None
        """

        for vert in self.getNeighbours(vertex):
            if vert not in self.connectedList:
                self.shortestPaths[vert]= self.shortestPaths[vertex]+[vert]
                self.connectedList.append(vert)

    def getShortestPaths(self, fromVert) -> dict:
        """
        Finding shortest path from particular node to nodes which are connected with it.
        
        Arguments:
            fromVert (any): vertex for which we checking paths
        Return:
            shortest_paths (dict): shortest paths for nodes which are connected to fromVert
        """

        self.connectedList=[fromVert]
        self.shortestPaths={fromVert: [fromVert]}
        
        for vertex in self.connectedList:
            self.checkPath(vertex)

        return (self.shortestPaths)
